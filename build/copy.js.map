{"version":3,"file":"copy.js","sources":["../source/types.ts","../source/get-grouped-folders.ts","../source/copy.ts"],"sourcesContent":["export enum StringConstant {\n    slash = '/'\n}\n\nexport enum CommandlineArguments {\n    source = 'source',\n    destination = 'destination',\n    exclude = 'exclude',\n    help = 'help'\n}\n\nexport enum ShortCommandlineArguments {\n    source = 's',\n    destination = 'd',\n    exclude = 'e',\n    help = 'h'\n}\n\n\nexport enum CommandlineArgumentsDescription {\n    source = 'Source path',\n    destination = 'Destination path',\n    exclude = 'Patterns to exclude',\n    help = 'List commandline options'\n}\n\nexport interface ICopy {\n    source: string;\n    destination: string;\n    exclude?: string;\n    currentWorkingDirectory?: string;\n}\n\nexport interface IGetGroupedFolders {\n    paths: string[];\n}","import { dirname } from 'path';\nimport { IGetGroupedFolders, StringConstant } from './types';\n\nconst { slash } = StringConstant;\n\nexport default function ({paths}: IGetGroupedFolders) {\n    const groups = [] as string[][];\n\n    let pathCount: number;\n    let group: string[];\n    let currentPaths = paths;\n    let currentPath: string;\n    let index = 0;\n\n\n\n    for (index; index < paths.length && currentPaths.length; index ++) {\n        currentPath = paths[index];\n        pathCount = currentPath.split(slash).length;\n\n        group = currentPaths.filter(currentPath => currentPath.split(slash).length === pathCount);\n\n        if (group.length) {\n            groups.push(group);\n\n            currentPaths = currentPaths.filter(currentPath => !group.includes(currentPath));\n        }\n    };\n\n    return groups;\n}","import { resolve as resolvePath } from 'path';\nimport { PathLike } from 'fs';\nimport getFolderContent from 'vamtiger-get-directory-content-recursive';\nimport createFolder from 'vamtiger-create-directory';\nimport { ICopy } from './types';\nimport getGroupedFolders from './get-grouped-folders';\nimport copyFile from 'vamtiger-copy-file';\n\nexport default async function ({ source: currentSource, destination: currentDestination, exclude: pattern, currentWorkingDirectory }: ICopy) {\n    const workingDirectory = currentWorkingDirectory || process.cwd();\n    const exclude = pattern && new RegExp(pattern);\n    const source = resolvePath(workingDirectory, currentSource);\n    const destination = resolvePath(workingDirectory, currentDestination);\n    const { directory, file } = await getFolderContent({\n        path: source,\n        classified: true\n    });\n    const sourceFolders = ((exclude && directory.filter(currentFolder => !(currentFolder as string).match(exclude)) || directory) as string[]);\n    const destinationFolders = sourceFolders.map(currentFolder => currentFolder.replace(source, destination));\n    const sourceFiles = (exclude && file.filter(currentFile => !(currentFile as string).match(exclude)) || file) as string[];\n    const groupedFolders = getGroupedFolders({\n        paths: destinationFolders\n    });\n    const copyFileParams = sourceFiles.map(sourceFile => ({\n        source: sourceFile,\n        destination: sourceFile.replace(source, destination)\n    }));\n\n    await groupedFolders.reduce(\n        (createFolders, folders) => createFolders.then(() => Promise.all(folders.map(folder => createFolder(folder as PathLike)))),\n        Promise.resolve() as Promise<any>\n    );\n\n    await Promise.all(copyFileParams.map(copyFile));\n}"],"names":["StringConstant","CommandlineArguments","ShortCommandlineArguments","CommandlineArgumentsDescription","slash","paths","groups","pathCount","group","currentPath","currentPaths","index","length","split","filter","push","includes","async","source","currentSource","destination","currentDestination","exclude","pattern","currentWorkingDirectory","workingDirectory","process","cwd","RegExp","resolvePath","directory","file","getFolderContent","path","classified","destinationFolders","currentFolder","match","map","replace","sourceFiles","currentFile","groupedFolders","getGroupedFolders","copyFileParams","sourceFile","reduce","createFolders","folders","then","Promise","all","folder","createFolder","resolve","copyFile"],"mappings":"qGAAYA,eAIAC,qBAOAC,0BAQAC,uQAnBZ,SAAYH,GACRA,YADJ,CAAYA,iBAAAA,oBAIZ,SAAYC,GACRA,kBACAA,4BACAA,oBACAA,cAJJ,CAAYA,uBAAAA,0BAOZ,SAAYC,GACRA,aACAA,kBACAA,cACAA,WAJJ,CAAYA,4BAAAA,+BAQZ,SAAYC,GACRA,uBACAA,iCACAA,gCACAA,kCAJJ,CAAYA,kCAAAA,qCChBZ,MAAMC,MAAEA,OAAUJ,eAElB,4BAAyBK,MAACA,IACtB,MAAMC,KAEN,IAAIC,EACAC,EAEAC,EADAC,EAAeL,EAEfM,EAAQ,EAIZ,KAAYA,EAAQN,EAAMO,QAAUF,EAAaE,OAAQD,IACrDF,EAAcJ,EAAMM,GACpBJ,EAAYE,EAAYI,MAAMT,OAAOQ,QAErCJ,EAAQE,EAAaI,OAAOL,GAAeA,EAAYI,MAAMT,OAAOQ,SAAWL,IAErEK,SACNN,EAAOS,KAAKP,GAEZE,EAAeA,EAAaI,OAAOL,IAAgBD,EAAMQ,SAASP,KAI1E,OAAOH,ECrBIW,qBAAkBC,OAAQC,EAAeC,YAAaC,EAAoBC,QAASC,EAAOC,wBAAEA,IACvG,MAAMC,EAAmBD,GAA2BE,QAAQC,MACtDL,EAAUC,GAAW,IAAIK,OAAOL,GAChCL,EAASW,aAAYJ,EAAkBN,GACvCC,EAAcS,aAAYJ,EAAkBJ,IAC5CS,UAAEA,EAASC,KAAEA,SAAeC,kBAC9BC,KAAMf,EACNgB,YAAY,IAGVC,GADkBb,GAAWQ,EAAUhB,OAAOsB,IAAmBA,EAAyBC,MAAMf,KAAaQ,GAC1EQ,IAAIF,GAAiBA,EAAcG,QAAQrB,EAAQE,IACtFoB,EAAelB,GAAWS,EAAKjB,OAAO2B,IAAiBA,EAAuBJ,MAAMf,KAAaS,EACjGW,EAAiBC,mBACnBtC,MAAO8B,IAELS,EAAiBJ,EAAYF,IAAIO,KACnC3B,OAAQ2B,EACRzB,YAAayB,EAAWN,QAAQrB,EAAQE,YAGtCsB,EAAeI,OACjB,CAACC,EAAeC,IAAYD,EAAcE,KAAK,IAAMC,QAAQC,IAAIH,EAAQV,IAAIc,GAAUC,aAAaD,MACpGF,QAAQI,iBAGNJ,QAAQC,IAAIP,EAAeN,IAAIiB"}