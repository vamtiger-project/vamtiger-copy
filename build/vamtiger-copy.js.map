{"version":3,"file":"vamtiger-copy.js","sources":["../source/types.ts","../source/get-grouped-folders.ts","../source/copy.ts","../source/vamtiger-copy.ts"],"sourcesContent":["export enum StringConstant {\n    slash = '/'\n}\n\nexport enum CommandlineArguments {\n    source = 'source',\n    destination = 'destination',\n    exclude = 'exclude',\n    help = 'help'\n}\n\nexport enum ShortCommandlineArguments {\n    source = 's',\n    destination = 'd',\n    exclude = 'e',\n    help = 'h'\n}\n\n\nexport enum CommandlineArgumentsDescription {\n    source = 'Source path',\n    destination = 'Destination path',\n    exclude = 'Patterns to exclude',\n    help = 'List commandline options'\n}\n\nexport interface ICopy {\n    source: string;\n    destination: string;\n    exclude?: string;\n    currentWorkingDirectory?: string;\n}\n\nexport interface IGetGroupedFolders {\n    paths: string[];\n}","import { dirname } from 'path';\nimport { IGetGroupedFolders, StringConstant } from './types';\n\nconst { slash } = StringConstant;\n\nexport default function ({paths}: IGetGroupedFolders) {\n    const groups = [] as string[][];\n\n    let pathCount: number;\n    let group: string[];\n    let currentPaths = paths;\n    let currentPath: string;\n    let index = 0;\n\n\n\n    for (index; index < paths.length && currentPaths.length; index ++) {\n        currentPath = paths[index];\n        pathCount = currentPath.split(slash).length;\n\n        group = currentPaths.filter(currentPath => currentPath.split(slash).length === pathCount);\n\n        if (group.length) {\n            groups.push(group);\n\n            currentPaths = currentPaths.filter(currentPath => !group.includes(currentPath));\n        }\n    };\n\n    return groups;\n}","import { resolve as resolvePath } from 'path';\nimport { PathLike } from 'fs';\nimport getFolderContent from 'vamtiger-get-directory-content-recursive';\nimport createFolder from 'vamtiger-create-directory';\nimport { ICopy } from './types';\nimport getGroupedFolders from './get-grouped-folders';\nimport copyFile from 'vamtiger-copy-file';\n\nexport default async function ({ source: currentSource, destination: currentDestination, exclude: pattern, currentWorkingDirectory }: ICopy) {\n    const workingDirectory = currentWorkingDirectory || process.cwd();\n    const exclude = pattern && new RegExp(pattern);\n    const source = resolvePath(workingDirectory, currentSource);\n    const destination = resolvePath(workingDirectory, currentDestination);\n    const { directory, file } = await getFolderContent({\n        path: source,\n        classified: true\n    });\n    const sourceFolders = ((exclude && directory.filter(currentFolder => !(currentFolder as string).match(exclude)) || directory) as string[]);\n    const destinationFolders = sourceFolders.map(currentFolder => currentFolder.replace(source, destination));\n    const sourceFiles = (exclude && file.filter(currentFile => !(currentFile as string).match(exclude)) || file) as string[];\n    const groupedFolders = getGroupedFolders({\n        paths: destinationFolders\n    });\n    const copyFileParams = sourceFiles.map(sourceFile => ({\n        source: sourceFile,\n        destination: sourceFile.replace(source, destination)\n    }));\n\n    await groupedFolders.reduce(\n        (createFolders, folders) => createFolders.then(() => Promise.all(folders.map(folder => createFolder(folder as PathLike)))),\n        Promise.resolve() as Promise<any>\n    );\n\n    await Promise.all(copyFileParams.map(copyFile));\n}","import Args from 'vamtiger-argv/build/main';\nimport getHelp from 'vamtiger-commandline-help';\nimport { CommandlineArguments, ShortCommandlineArguments, CommandlineArgumentsDescription } from './types';\nimport copy from './copy';\n\nconst args = new Args();\nconst source = args.get(CommandlineArguments.source)\n    || args.get(ShortCommandlineArguments.source);\nconst destination = args.get(CommandlineArguments.destination)\n    || args.get(ShortCommandlineArguments.destination);\nconst exclude = args.get(CommandlineArguments.exclude)\n    || args.get(ShortCommandlineArguments.exclude);\nconst help = !(source && destination);\n\nif (help) {\n    logHelp();\n} else if (source && destination) {\n    copy({source, destination, exclude}).catch(handleError);\n}\n\nfunction logHelp() {\n    const helpText = getHelp({\n        args: CommandlineArguments,\n        short: ShortCommandlineArguments,\n        description: CommandlineArgumentsDescription\n    });\n\n    console.log(helpText);\n}\n\nfunction handleError(error: Error) {\n    console.error(error);\n    process.exit(1);\n}\n\nexport { default as copy } from './copy';"],"names":["StringConstant","CommandlineArguments","ShortCommandlineArguments","CommandlineArgumentsDescription","slash","paths","groups","pathCount","group","currentPath","currentPaths","index","length","split","filter","push","includes","async","source","currentSource","destination","currentDestination","exclude","pattern","currentWorkingDirectory","workingDirectory","process","cwd","RegExp","resolvePath","directory","file","getFolderContent","path","classified","destinationFolders","currentFolder","match","map","replace","sourceFiles","currentFile","groupedFolders","getGroupedFolders","copyFileParams","sourceFile","reduce","createFolders","folders","then","Promise","all","folder","createFolder","resolve","copyFile","args","Args","get","help","logHelp","helpText","getHelp","short","description","console","log","handleError","error","exit","copy","catch"],"mappings":"4JAAYA,eAIAC,qBAOAC,0BAQAC,+XAnBZ,SAAYH,GACRA,YADJ,CAAYA,iBAAAA,oBAIZ,SAAYC,GACRA,kBACAA,4BACAA,oBACAA,cAJJ,CAAYA,uBAAAA,0BAOZ,SAAYC,GACRA,aACAA,kBACAA,cACAA,WAJJ,CAAYA,4BAAAA,+BAQZ,SAAYC,GACRA,uBACAA,iCACAA,gCACAA,kCAJJ,CAAYA,kCAAAA,qCChBZ,MAAMC,MAAEA,OAAUJ,eAElB,4BAAyBK,MAACA,IACtB,MAAMC,KAEN,IAAIC,EACAC,EAEAC,EADAC,EAAeL,EAEfM,EAAQ,EAIZ,KAAYA,EAAQN,EAAMO,QAAUF,EAAaE,OAAQD,IACrDF,EAAcJ,EAAMM,GACpBJ,EAAYE,EAAYI,MAAMT,OAAOQ,QAErCJ,EAAQE,EAAaI,OAAOL,GAAeA,EAAYI,MAAMT,OAAOQ,SAAWL,IAErEK,SACNN,EAAOS,KAAKP,GAEZE,EAAeA,EAAaI,OAAOL,IAAgBD,EAAMQ,SAASP,KAI1E,OAAOH,ECrBIW,qBAAkBC,OAAQC,EAAeC,YAAaC,EAAoBC,QAASC,EAAOC,wBAAEA,IACvG,MAAMC,EAAmBD,GAA2BE,QAAQC,MACtDL,EAAUC,GAAW,IAAIK,OAAOL,GAChCL,EAASW,aAAYJ,EAAkBN,GACvCC,EAAcS,aAAYJ,EAAkBJ,IAC5CS,UAAEA,EAASC,KAAEA,SAAeC,kBAC9BC,KAAMf,EACNgB,YAAY,IAGVC,GADkBb,GAAWQ,EAAUhB,OAAOsB,IAAmBA,EAAyBC,MAAMf,KAAaQ,GAC1EQ,IAAIF,GAAiBA,EAAcG,QAAQrB,EAAQE,IACtFoB,EAAelB,GAAWS,EAAKjB,OAAO2B,IAAiBA,EAAuBJ,MAAMf,KAAaS,EACjGW,EAAiBC,mBACnBtC,MAAO8B,IAELS,EAAiBJ,EAAYF,IAAIO,KACnC3B,OAAQ2B,EACRzB,YAAayB,EAAWN,QAAQrB,EAAQE,YAGtCsB,EAAeI,OACjB,CAACC,EAAeC,IAAYD,EAAcE,KAAK,IAAMC,QAAQC,IAAIH,EAAQV,IAAIc,GAAUC,aAAaD,MACpGF,QAAQI,iBAGNJ,QAAQC,IAAIP,EAAeN,IAAIiB,WC5BzC,MAAMC,KAAO,IAAIC,KACXvC,OAASsC,KAAKE,IAAIzD,qBAAqBiB,SACtCsC,KAAKE,IAAIxD,0BAA0BgB,QACpCE,YAAcoC,KAAKE,IAAIzD,qBAAqBmB,cAC3CoC,KAAKE,IAAIxD,0BAA0BkB,aACpCE,QAAUkC,KAAKE,IAAIzD,qBAAqBqB,UACvCkC,KAAKE,IAAIxD,0BAA0BoB,SACpCqC,OAASzC,QAAUE,aAQzB,SAASwC,UACL,MAAMC,EAAWC,SACbN,KAAMvD,qBACN8D,MAAO7D,0BACP8D,YAAa7D,kCAGjB8D,QAAQC,IAAIL,GAGhB,SAASM,YAAYC,GACjBH,QAAQG,MAAMA,GACd1C,QAAQ2C,KAAK,GAlBbV,KACAC,UACO1C,QAAUE,aACjBkD,MAAMpD,OAAAA,OAAQE,YAAAA,YAAaE,QAAAA,UAAUiD,MAAMJ"}